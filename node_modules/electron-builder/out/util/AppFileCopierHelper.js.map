{"version":3,"file":"AppFileCopierHelper.js","sourceRoot":"","sources":["../../src/util/AppFileCopierHelper.ts"],"names":[],"mappings":"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","sourcesContent":["import BluebirdPromise from \"bluebird-lst\"\nimport { debug, log } from \"builder-util\"\nimport { CONCURRENCY, FileTransformer, statOrNull, walk } from \"builder-util/out/fs\"\nimport { ensureDir, Stats } from \"fs-extra-p\"\nimport * as path from \"path\"\nimport { FileMatcher } from \"../fileMatcher\"\nimport { createElectronCompilerHost } from \"../fileTransformer\"\nimport { Packager } from \"../packager\"\nimport { AppFileWalker } from \"./AppFileWalker\"\n\n/** @internal */\nexport const NODE_MODULES_PATTERN = `${path.sep}node_modules${path.sep}`\n\n// os path separator is used\nexport interface ResolvedFileSet {\n  src: string\n  destination: string\n\n  files: Array<string>\n  metadata: Map<string, Stats>\n  transformedFiles: Array<string | Buffer | true | null>\n}\n\nexport async function computeFileSets(matchers: Array<FileMatcher>, transformer: FileTransformer, packager: Packager, isElectronCompile: boolean): Promise<Array<ResolvedFileSet>> {\n  const fileSets: Array<ResolvedFileSet> = []\n  for (const matcher of matchers) {\n    const fileWalker = new AppFileWalker(matcher, packager)\n\n    const fromStat = await statOrNull(fileWalker.matcher.from)\n    if (fromStat == null) {\n      debug(`Directory ${fileWalker.matcher.from} doesn't exists, skip file copying`)\n      continue\n    }\n\n    const files = await walk(fileWalker.matcher.from, fileWalker.filter, fileWalker)\n    const metadata = fileWalker.metadata\n\n    const transformedFiles = await BluebirdPromise.map(files, it => {\n      const fileStat = metadata.get(it)\n      return fileStat != null && fileStat.isFile() ? transformer(it) : null\n    }, CONCURRENCY)\n\n    fileSets.push({src: fileWalker.matcher.from, files, metadata: fileWalker.metadata, transformedFiles, destination: fileWalker.matcher.to})\n  }\n\n  const mainFileSet = fileSets[0]\n  if (isElectronCompile) {\n    // cache should be first in the asar\n    fileSets.unshift(await compileUsingElectronCompile(mainFileSet, packager))\n  }\n  return fileSets\n}\n\nconst BOWER_COMPONENTS_PATTERN = `${path.sep}bower_components${path.sep}`\n/** @internal */\nexport const ELECTRON_COMPILE_SHIM_FILENAME = \"__shim.js\"\n\nasync function compileUsingElectronCompile(mainFileSet: ResolvedFileSet, packager: Packager): Promise<ResolvedFileSet> {\n  log(\"Compiling using electron-compile\")\n\n  const electronCompileCache = await packager.tempDirManager.getTempDir({prefix: \"electron-compile-cache\"})\n  const cacheDir = path.join(electronCompileCache, \".cache\")\n  // clear and create cache dir\n  await ensureDir(cacheDir)\n  const compilerHost = await createElectronCompilerHost(mainFileSet.src, cacheDir)\n  const nextSlashIndex = mainFileSet.src.length + 1\n  // pre-compute electron-compile to cache dir - we need to process only subdirectories, not direct files of app dir\n  await BluebirdPromise.map(mainFileSet.files, file => {\n    if (file.includes(NODE_MODULES_PATTERN) || file.includes(BOWER_COMPONENTS_PATTERN)\n      || !file.includes(path.sep, nextSlashIndex) // ignore not root files\n      || !mainFileSet.metadata.get(file)!.isFile()) {\n      return null\n    }\n    return compilerHost.compile(file)\n      .then((it: any) => null)\n  }, CONCURRENCY)\n\n  await compilerHost.saveConfiguration()\n\n  const metadata = new Map<string, Stats>()\n  const cacheFiles = await walk(cacheDir, (file, stat) => !file.startsWith(\".\"), {\n    consume: (file, fileStat) => {\n      if (fileStat.isFile()) {\n        metadata.set(file, fileStat)\n      }\n      return null\n    }\n  })\n\n  // add shim\n  const shimPath = `${mainFileSet.src}/${ELECTRON_COMPILE_SHIM_FILENAME}`\n  cacheFiles.push(shimPath)\n  metadata.set(shimPath, {isFile: () => true, isDirectory: () => false} as any)\n\n  const transformedFiles = new Array(cacheFiles.length)\n  transformedFiles[cacheFiles.length - 1] = `\n'use strict';\nrequire('electron-compile').init(__dirname, require('path').resolve(__dirname, '${packager.metadata.main || \"index\"}'), true);\n`\n  // cache files should be first (better IO)\n  return {src: electronCompileCache, files: cacheFiles, transformedFiles, metadata, destination: mainFileSet.destination}\n}\n\n// sometimes, destination may not contain path separator in the end (path to folder), but the src does. So let's ensure paths have path separators in the end\nexport function ensureEndSlash(s: string) {\n  return s === \"\" || s.endsWith(path.sep) ? s : (s + path.sep)\n}"]}
