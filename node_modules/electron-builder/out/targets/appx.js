"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = require("bluebird-lst");
}

var _bluebirdLst2;

function _load_bluebirdLst2() {
    return _bluebirdLst2 = _interopRequireDefault(require("bluebird-lst"));
}

exports.quoteString = quoteString;

var _builderUtil;

function _load_builderUtil() {
    return _builderUtil = require("builder-util");
}

var _fs;

function _load_fs() {
    return _fs = require("builder-util/out/fs");
}

var _debug2 = _interopRequireDefault(require("debug"));

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = require("fs-extra-p");
}

var _path = _interopRequireWildcard(require("path"));

var _deepAssign;

function _load_deepAssign() {
    return _deepAssign = require("read-config-file/out/deepAssign");
}

var _core;

function _load_core() {
    return _core = require("../core");
}

var _pathManager;

function _load_pathManager() {
    return _pathManager = require("../util/pathManager");
}

var _windowsCodeSign;

function _load_windowsCodeSign() {
    return _windowsCodeSign = require("../windowsCodeSign");
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

const APPX_ASSETS_DIR_NAME = "appx";
const vendorAssetsForDefaultAssets = {
    "StoreLogo.png": "SampleAppx.50x50.png",
    "Square150x150Logo.png": "SampleAppx.150x150.png",
    "Square44x44Logo.png": "SampleAppx.44x44.png",
    "Wide310x150Logo.png": "SampleAppx.310x150.png"
};
const DEFAULT_RESOURCE_LANG = "en-US";
const debug = (0, _debug2.default)("electron-builder:appx");
class AppXTarget extends (_core || _load_core()).Target {
    constructor(packager, outDir) {
        super("appx");
        this.packager = packager;
        this.outDir = outDir;
        this.options = (0, (_deepAssign || _load_deepAssign()).deepAssign)({}, this.packager.platformSpecificBuildOptions, this.packager.config.appx);
        if (process.platform !== "win32" || (0, (_windowsCodeSign || _load_windowsCodeSign()).isOldWin6)() || process.env.PARALLELS_VM_ID == null) {
            throw new Error("AppX is supported only on Windows 10 or Windows Server 2012 R2 (version number 6.3+)");
        }
    }
    build(appOutDir, arch) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const packager = _this.packager;
            const cscInfo = yield _this.packager.cscInfo.value;
            if (cscInfo == null) {
                throw new Error("AppX package must be signed, but certificate is not set, please see https://electron.build/code-signing\n\nYou can use `electron-builder create-self-signed-cert -p YourName` to create self-signed certificate");
            }
            let publisher = _this.options.publisher;
            if (publisher == null) {
                const cscFile = cscInfo.file;
                if (cscFile == null) {
                    throw new Error("Please specify appx.publisher: cannot get publisher from your code signing certificate if EV cert is used");
                }
                publisher = yield packager.computedPublisherSubjectOnWindowsOnly.value;
                if (!publisher) {
                    throw new Error("Please specify appx.publisher, cannot compute from p12 file");
                }
            }
            const preAppx = _path.join(_this.outDir, `pre-appx-${(0, (_builderUtil || _load_builderUtil()).getArchSuffix)(arch)}`);
            yield (0, (_fsExtraP || _load_fsExtraP()).emptyDir)(preAppx);
            const assetOutDir = _path.join(preAppx, "assets");
            yield (0, (_fsExtraP || _load_fsExtraP()).mkdir)(assetOutDir);
            const userAssetDir = yield packager.getResource(undefined, APPX_ASSETS_DIR_NAME);
            let userAssets;
            if (userAssetDir == null) {
                userAssets = [];
            } else {
                userAssets = (yield (0, (_fsExtraP || _load_fsExtraP()).readdir)(userAssetDir)).filter(function (it) {
                    return !it.startsWith(".") && !it.endsWith(".db") && it.indexOf(".") !== -1;
                });
                yield (_bluebirdLst2 || _load_bluebirdLst2()).default.map(userAssets, function (it) {
                    return (0, (_fs || _load_fs()).copyOrLinkFile)(_path.join(userAssetDir, it), _path.join(assetOutDir, it));
                });
            }
            const vendorPath = yield (0, (_windowsCodeSign || _load_windowsCodeSign()).getSignVendorPath)();
            const taskManager = new (_builderUtil || _load_builderUtil()).AsyncTaskManager(packager.info.cancellationToken);
            taskManager.addTask((_bluebirdLst2 || _load_bluebirdLst2()).default.map(Object.keys(vendorAssetsForDefaultAssets), function (defaultAsset) {
                if (!isDefaultAssetIncluded(userAssets, defaultAsset)) {
                    return (0, (_fs || _load_fs()).copyOrLinkFile)(_path.join(vendorPath, "appxAssets", vendorAssetsForDefaultAssets[defaultAsset]), _path.join(assetOutDir, defaultAsset));
                }
                return null;
            }));
            taskManager.addTask(_this.writeManifest((0, (_pathManager || _load_pathManager()).getTemplatePath)("appx"), preAppx, arch, publisher, userAssets));
            taskManager.addTask((0, (_fs || _load_fs()).copyDir)(appOutDir, _path.join(preAppx, "app")));
            yield taskManager.awaitTasks();
            const artifactName = packager.expandArtifactNamePattern(_this.options, "appx", arch);
            const artifactPath = _path.join(_this.outDir, artifactName);
            const makeAppXArgs = ["pack", "/o", "/d", preAppx, "/p", artifactPath];
            // we do not use process.arch to build path to tools, because even if you are on x64, ia32 appx tool must be used if you build appx for ia32
            if (isScaledAssetsProvided(userAssets)) {
                const priConfigPath = _path.join(preAppx, "priconfig.xml");
                const makePriPath = _path.join(vendorPath, "windows-10", (_builderUtil || _load_builderUtil()).Arch[arch], "makepri.exe");
                yield (0, (_builderUtil || _load_builderUtil()).spawn)(makePriPath, ["createconfig", "/cf", priConfigPath, "/dq", "en-US", "/pv", "10.0.0", "/o"], undefined, { isDebugEnabled: debug.enabled });
                yield (0, (_builderUtil || _load_builderUtil()).spawn)(makePriPath, ["new", "/pr", preAppx, "/cf", priConfigPath, "/of", preAppx], undefined, { isDebugEnabled: debug.enabled });
                makeAppXArgs.push("/l");
            }
            (0, (_builderUtil || _load_builderUtil()).use)(_this.options.makeappxArgs, function (it) {
                return makeAppXArgs.push.apply(makeAppXArgs, _toConsumableArray(it));
            });
            // wine supports only ia32 binary in any case makeappx crashed on wine
            if (process.env.PARALLELS_VM_ID) {
                yield (0, (_builderUtil || _load_builderUtil()).spawn)(_path.join(vendorPath, "windows-10", (_builderUtil || _load_builderUtil()).Arch[arch], "makeappx.exe"), makeAppXArgs, undefined, { isDebugEnabled: debug.enabled });
            } else {
                yield (0, (_builderUtil || _load_builderUtil()).spawn)(_path.join(vendorPath, "windows-10", (_builderUtil || _load_builderUtil()).Arch[arch], "makeappx.exe"), makeAppXArgs, undefined, { isDebugEnabled: debug.enabled });
            }
            yield packager.sign(artifactPath);
            packager.info.dispatchArtifactCreated({
                file: artifactPath,
                packager,
                arch,
                safeArtifactName: packager.computeSafeArtifactName(artifactName, "appx"),
                target: _this,
                isWriteUpdateInfo: _this.options.electronUpdaterAware
            });
        })();
    }
    writeManifest(templatePath, preAppx, arch, publisher, userAssets) {
        var _this2 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const appInfo = _this2.packager.appInfo;
            const options = _this2.options;
            const manifest = (yield (0, (_fsExtraP || _load_fsExtraP()).readFile)(_path.join(templatePath, "appxmanifest.xml"), "utf8")).replace(/\$\{([a-zA-Z0-9]+)\}/g, function (match, p1) {
                switch (p1) {
                    case "publisher":
                        return publisher;
                    case "publisherDisplayName":
                        const name = options.publisherDisplayName || appInfo.companyName;
                        if (name == null) {
                            throw new Error(`Please specify "author" in the application package.json — it is required because "appx.publisherDisplayName" is not set.`);
                        }
                        return name;
                    case "version":
                        return appInfo.versionInWeirdWindowsForm;
                    case "applicationId":
                        const result = options.applicationId || options.identityName || appInfo.name;
                        if (!isNaN(parseInt(result[0], 10))) {
                            let message = `AppX Application.Id can’t start with numbers: "${result}"`;
                            if (options.applicationId == null) {
                                message += `\nPlease set appx.applicationId (or correct appx.identityName or name)`;
                            }
                            throw new Error(message);
                        }
                        return result;
                    case "identityName":
                        return options.identityName || appInfo.name;
                    case "executable":
                        return `app\\${appInfo.productFilename}.exe`;
                    case "displayName":
                        return options.displayName || appInfo.productName;
                    case "description":
                        return appInfo.description || appInfo.productName;
                    case "backgroundColor":
                        return options.backgroundColor || "#464646";
                    case "logo":
                        return "assets\\StoreLogo.png";
                    case "square150x150Logo":
                        return "assets\\Square150x150Logo.png";
                    case "square44x44Logo":
                        return "assets\\Square44x44Logo.png";
                    case "lockScreen":
                        return lockScreenTag(userAssets);
                    case "defaultTile":
                        return defaultTileTag(userAssets);
                    case "splashScreen":
                        return splashScreenTag(userAssets);
                    case "arch":
                        return arch === (_builderUtil || _load_builderUtil()).Arch.ia32 ? "x86" : "x64";
                    case "resourceLanguages":
                        return resourceLanguageTag((0, (_builderUtil || _load_builderUtil()).asArray)(options.languages));
                    default:
                        throw new Error(`Macro ${p1} is not defined`);
                }
            });
            yield (0, (_fsExtraP || _load_fsExtraP()).writeFile)(_path.join(preAppx, "appxmanifest.xml"), manifest);
        })();
    }
}
exports.default = AppXTarget; // get the resource - language tag, see https://docs.microsoft.com/en-us/windows/uwp/globalizing/manage-language-and-region#specify-the-supported-languages-in-the-apps-manifest

function resourceLanguageTag(userLanguages) {
    if (userLanguages == null || userLanguages.length === 0) {
        userLanguages = [DEFAULT_RESOURCE_LANG];
    }
    return userLanguages.map(it => `<Resource Language="${it.replace(/_/g, "-")}" />`).join("\n");
}
function lockScreenTag(userAssets) {
    if (isDefaultAssetIncluded(userAssets, "BadgeLogo.png")) {
        return '<uap:LockScreen Notification="badgeAndTileText" BadgeLogo="assets\\BadgeLogo.png" />';
    } else {
        return "";
    }
}
function defaultTileTag(userAssets) {
    const defaultTiles = ["<uap:DefaultTile", 'Wide310x150Logo="assets\\Wide310x150Logo.png"'];
    if (isDefaultAssetIncluded(userAssets, "LargeTile.png")) {
        defaultTiles.push('Square310x310Logo="assets\\LargeTile.png"');
    }
    if (isDefaultAssetIncluded(userAssets, "SmallTile.png")) {
        defaultTiles.push('Square71x71Logo="assets\\SmallTile.png"');
    }
    defaultTiles.push("/>");
    return defaultTiles.join(" ");
}
function splashScreenTag(userAssets) {
    if (isDefaultAssetIncluded(userAssets, "SplashScreen.png")) {
        return '<uap:SplashScreen Image="assets\\SplashScreen.png" />';
    } else {
        return "";
    }
}
function isDefaultAssetIncluded(userAssets, defaultAsset) {
    const defaultAssetName = defaultAsset.substring(0, defaultAsset.indexOf("."));
    return userAssets.some(it => it.indexOf(defaultAssetName) !== -1);
}
function isScaledAssetsProvided(userAssets) {
    return userAssets.some(it => it.indexOf(".scale-") !== -1 || it.indexOf(".targetsize-") !== -1);
}
function quoteString(s) {
    if (!(s.indexOf(",") !== -1) && !(s.indexOf('"') !== -1)) {
        return s;
    }
    return `"${s.replace(/"/g, '\\"')}"`;
}
//# sourceMappingURL=appx.js.map